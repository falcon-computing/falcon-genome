#include <boost/filesystem.hpp>
#include <boost/filesystem/fstream.hpp>
#include <boost/program_options.hpp>
#include <cmath>
#include <iomanip>
#include <glog/logging.h>
#include <string>

#include "fcs-genome/common.h"
#include "fcs-genome/config.h"
#include "fcs-genome/Executor.h"
#include "fcs-genome/workers.h"

namespace fcsgenome {

int htc_main(int argc, char** argv,
    boost::program_options::options_description &opt_desc) 
{
  namespace po = boost::program_options;

  // Define arguments
  po::variables_map cmd_vm;

  opt_desc.add_options() 
    arg_decl_string("ref,r", "reference genome path")
    arg_decl_string("input,i", "input BAM file or dir")
    arg_decl_string("output,o", "output BAM files")
    ("skip-concat|s", "skip GVCF files concatination")
    ("help,h", "print help messages")
    ("force,f", "overwrite output file if exists");

  // Parse arguments
  po::store(po::parse_command_line(argc, argv, opt_desc),
      cmd_vm);

  if (cmd_vm.count("help")) { 
    throw helpRequest();
  } 

  // Check if required arguments are presented
  bool flag_f             = get_argument<bool>(cmd_vm, "force");
  bool flag_skip_concat   = get_argument<bool>(cmd_vm, "force");
  std::string ref_path    = get_argument<std::string>(cmd_vm, "ref",
                                conf_default_ref);
  std::string input_path  = get_argument<std::string>(cmd_vm, "input");
  std::string output_path = get_argument<std::string>(cmd_vm, "output");

  // finalize argument parsing
  po::notify(cmd_vm);

  // TODO: deal with the case where 
  // 1. output_path is a dir but should not be deleted
  // 2. output_path is a file
  std::string output_dir = output_path;
  if (!flag_skip_concat) {
    output_dir += ".parts";
  }
  try {
    check_output(output_dir, flag_f, true);
  } catch (fileNotFound &e) {
    // this means output_path is a directory and exists
    // create a new directory and try again
    output_dir = output_dir + ".new";
    DLOG(INFO) << "rename output path to " << output_dir;
    if (boost::filesystem::exists(output_dir)) {
      throw internalError("invalid output path");
    }
  }
  create_dir(output_dir);
  std::vector<std::string> output_files(conf_gatk_ncontigs);
  std::vector<std::string> intv_paths = init_contig_intv(ref_path);

  Executor executor("Haplotype Caller", conf_htc_nprocs);

  for (int contig = 0; contig < conf_gatk_ncontigs; contig++) {
    std::string input_file;
    if (boost::filesystem::is_directory(input_path)) {
      // if input is a directory, automatically go into contig mode
      // TODO: here should validate if the bam files in folder
      //       is generated by fcs-genome with the same num contigs
      input_file = get_contig_fname(input_path, contig);
    }
    else {
      input_file = input_path;
    }
    std::string output_file = get_contig_fname(output_dir, contig, "gvcf");
    Worker_ptr worker(new HTCWorker(ref_path,
          intv_paths[contig], input_file,
          output_file,
          contig, flag_f));
    output_files[contig] = output_file;

    executor.addTask(worker);
  }
  executor.run();

  if (!flag_skip_concat) {
    Executor executor("concat GVCFs");
    { // concat gvcfs
      Worker_ptr worker(new VCFConcatWorker(
            output_files, output_path,
            flag_f));
      executor.addTask(worker);
    }
    executor.run();
    { // bgzip gvcf
      Worker_ptr worker(new ZIPWorker(
            output_path, output_path+".gz",
            flag_f));
      executor.addTask(worker, true);
    }
    executor.run();
    { // tabix gvcf
      Worker_ptr worker(new TabixWorker(
            output_path + ".gz"));
      executor.addTask(worker, true);
    }
    executor.run();

    remove_path(output_dir);
    remove_path(output_path);
  }
  return 0;
}
} // namespace fcsgenome
